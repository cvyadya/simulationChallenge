---
title: "Simulation Challenge"
subtitle: "Starter Template with To-Dos"
format:
  html: default
execute:
  echo: true
  eval: true
---

# ðŸŽ² Simulation Challenge - Starter Template

:::: {.callout-important}
## ðŸ“‹ What You Need To Do

- [ ] Fork and create repo `simulationChallenge` in your GitHub
- [ ] Clone locally and open in Cursor
- [ ] Write your analysis in this `index.qmd`
- [ ] Render to HTML (`quarto render` or Render button)
- [ ] Push HTML to your repo and enable GitHub Pages
- [ ] Share your site: `https://[your-username].github.io/simulationChallenge/`
:::

:::: {.callout-warning}
## âš ï¸ AI Partnership Required
Use Cursor AI for speed, but ensure you understand and can explain the results in your own words.  Verify cursor's calculations as investment simulation is tricky.
:::

## The Investment Game (Brief)

You have the opportunity to buy-in to this game next week with $30,000. Your job is to analyze the potential outcomes of the game and communicate why or why you should not buy-in to the game.  

Each year after buy-in you flip a fair coin:

- Heads: increase your account balance by 50%
- Tails: decrease your account balance by 40%

You play annually until age 75. Your mission is to analyze outcomes and communicate insights clearly.

### Generative DAG Model (from the source challenge)

The following DAFT diagram shows the generative structure of the investment game over time.

## Analysis Tasks (Fill These In)

::::: {.callout-note}
## Grading Scope

- Sections 1â€“4: required and can earn up to 90% of the grade.
- Sections 5â€“6: optional; strong, well-supported work here can bring your score up to 100%.
::::

### 1) Expected Value After 1 Flip

TODO: Explain whether the expected value of your account balance after one flip is >, =, or < $30,000. What is the gain in expected value as a percentage of your buy-in? Does this simple analysis suggest you should buy-in to the game?

```{python}
#| label: q1-expected-value-py
#| echo: false


# Parameters
initial_wealth = 30000
prob_heads = 0.5
multiplier_heads = 1.5  # +50% increase
multiplier_tails = 0.6  # -40% decrease

# Calculate expected value after one flip
# EV = P(heads) * (initial * 1.5) + P(tails) * (initial * 0.6)
#    = 0.5 * 45,000 + 0.5 * 18,000
#    = 31,500

ev_after_one_flip = prob_heads * (initial_wealth * multiplier_heads) + \
                     (1 - prob_heads) * (initial_wealth * multiplier_tails)

# Alternative calculation using expected multiplier
expected_multiplier = prob_heads * multiplier_heads + (1 - prob_heads) * multiplier_tails
ev_alternative = initial_wealth * expected_multiplier

# Calculate gain in expected value
expected_gain = ev_after_one_flip - initial_wealth
gain_percentage = (expected_gain / initial_wealth) * 100

# Display results
print(f"Initial Wealth: ${initial_wealth:,.2f}")
print(f"\nExpected Value After 1 Flip: ${ev_after_one_flip:,.2f}")
print(f"Expected Gain: ${expected_gain:,.2f}")
print(f"Gain as Percentage of Buy-in: {gain_percentage:.2f}%")
print(f"\nComparison: Expected Value ${ev_after_one_flip:,.2f} > Initial ${initial_wealth:,.2f}")
```

### 2) Single Simulation Over Time (Narrative + Plot)

Briefly narrate and visualize what happens to your account balance over the course of one run. Are you happy with the outcome? Why? or Why not?  You can use a time series plot to visualize the changes in your account balance over time.

```{python}
#| label: q2-single-sim-py
#| echo: false
#| fig-cap: "Single simulation path of account balance"

import numpy as np
import matplotlib.pyplot as plt

# Set seed for reproducibility
np.random.seed(42)

# Parameters
initial_wealth = 30000
prob_heads = 0.5
multiplier_heads = 1.5  # +50% increase
multiplier_tails = 0.6  # -40% decrease
num_years = 40  # Assuming starting at age 35, playing until 75

# Initialize arrays to store simulation results
years = np.arange(0, num_years + 1)  # Include year 0 (initial)
wealth = np.zeros(num_years + 1)
wealth[0] = initial_wealth

# Simulate coin flips and update wealth
for year in range(1, num_years + 1):
    # Flip coin: 1 = heads, 0 = tails
    coin_flip = np.random.binomial(1, prob_heads)
    
    # Update wealth based on coin flip
    if coin_flip == 1:  # Heads
        wealth[year] = wealth[year - 1] * multiplier_heads
    else:  # Tails
        wealth[year] = wealth[year - 1] * multiplier_tails

# Create figure using object-oriented matplotlib
fig, ax = plt.subplots(figsize=(10, 6))

# Plot the time series
ax.plot(years, wealth, linewidth=2, color='steelblue', marker='o', markersize=3)

# Add horizontal line at initial wealth for reference
ax.axhline(y=initial_wealth, color='gray', linestyle='--', linewidth=1, 
           label=f'Initial: ${initial_wealth:,.0f}')

# Formatting
ax.set_xlabel('Year', fontsize=12)
ax.set_ylabel('Account Balance ($)', fontsize=12)
ax.set_title('Single Simulation: Account Balance Over Time', fontsize=14, fontweight='bold')
ax.grid(True, alpha=0.3)
ax.legend(fontsize=10)

# Format y-axis to show currency values
ax.yaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: f'${x:,.0f}'))

# Display final balance
final_balance = wealth[-1]
print(f"Initial Balance: ${initial_wealth:,.2f}")
print(f"Final Balance: ${final_balance:,.2f}")
print(f"Net Change: ${final_balance - initial_wealth:,.2f}")
print(f"Return: {((final_balance / initial_wealth) - 1) * 100:.2f}%")

plt.tight_layout()
plt.show()
```

### 3) 100 Simulations: Distribution of Final Balances

TODO: Visually and narratively describe the distribution of your account balance after running the 100 simulations. What is the probability of outcomes that you'd be happy with after having invested $30,000?

```{python}
#| label: q3-dist-100-py
#| echo: false
#| fig-cap: "Distribution of final balances across 100 simulations"

import numpy as np
import matplotlib.pyplot as plt

# Set seed for reproducibility
np.random.seed(42)

# Parameters
initial_wealth = 30000
prob_heads = 0.5
multiplier_heads = 1.5  # +50% increase
multiplier_tails = 0.6  # -40% decrease
num_years = 40  # Assuming starting at age 35, playing until 75
num_simulations = 100

# Function to simulate one complete game
def simulate_game(initial, prob_heads, mult_heads, mult_tails, years):
    """Simulate one game and return final balance"""
    wealth = initial
    for _ in range(years):
        coin_flip = np.random.binomial(1, prob_heads)
        if coin_flip == 1:  # Heads
            wealth = wealth * mult_heads
        else:  # Tails
            wealth = wealth * mult_tails
    return wealth

# Run 100 simulations
final_balances = []
for sim in range(num_simulations):
    final_balance = simulate_game(initial_wealth, prob_heads, 
                                   multiplier_heads, multiplier_tails, num_years)
    final_balances.append(final_balance)

final_balances = np.array(final_balances)

# Calculate statistics
mean_final = np.mean(final_balances)
median_final = np.median(final_balances)
prob_above_initial = np.mean(final_balances > initial_wealth)

# Create figure with two subplots for better visualization
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(16, 6))

# Left plot: Histogram with log-scale bins (log-space binning)
# This better shows the distribution when values span multiple orders of magnitude
min_balance = np.min(final_balances)
max_balance = np.max(final_balances)

# Create log-spaced bins
log_min = np.log10(max(min_balance, 1))  # Avoid log(0)
log_max = np.log10(max_balance)
log_bins = np.logspace(log_min, log_max, num=50)  # 50 bins in log space

n, bins, patches = ax1.hist(final_balances, bins=log_bins, edgecolor='black', 
                          alpha=0.7, color='steelblue')

# Add vertical lines
ax1.axvline(x=initial_wealth, color='red', linestyle='--', linewidth=2,
           label=f'Initial: ${initial_wealth:,.0f}')
ax1.axvline(x=mean_final, color='green', linestyle='--', linewidth=2,
           label=f'Mean: ${mean_final:,.0f}')
ax1.axvline(x=median_final, color='orange', linestyle='--', linewidth=2,
           label=f'Median: ${median_final:,.0f}')

ax1.set_xscale('log')
ax1.set_xlabel('Final Account Balance ($, log scale)', fontsize=12)
ax1.set_ylabel('Frequency', fontsize=12)
ax1.set_title('Distribution with Log-Scale Binning', fontsize=13, fontweight='bold')
ax1.grid(True, alpha=0.3, axis='both', which='both')
ax1.legend(fontsize=9)

# Format x-axis to show currency values (works with log scale)
ax1.xaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: f'${x:,.0f}'))

# Right plot: Histogram with better linear binning (more bins, wider range)
# Use more bins and ensure we capture the full range
num_bins = 50
bins_linear = np.linspace(min_balance * 0.9, max_balance * 1.1, num_bins + 1)

n2, bins2, patches2 = ax2.hist(final_balances, bins=bins_linear, edgecolor='black', 
                               alpha=0.7, color='steelblue')

# Add vertical lines
ax2.axvline(x=initial_wealth, color='red', linestyle='--', linewidth=2,
           label=f'Initial: ${initial_wealth:,.0f}')
ax2.axvline(x=mean_final, color='green', linestyle='--', linewidth=2,
           label=f'Mean: ${mean_final:,.0f}')
ax2.axvline(x=median_final, color='orange', linestyle='--', linewidth=2,
           label=f'Median: ${median_final:,.0f}')

ax2.set_xlabel('Final Account Balance ($)', fontsize=12)
ax2.set_ylabel('Frequency', fontsize=12)
ax2.set_title('Distribution with Linear Binning (More Bins)', fontsize=13, fontweight='bold')
ax2.grid(True, alpha=0.3, axis='y')
ax2.legend(fontsize=9)

# Format x-axis to show currency values
ax2.xaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: f'${x:,.0f}'))

# Display statistics
print(f"Summary Statistics from {num_simulations} Simulations:")
print(f"  Mean Final Balance: ${mean_final:,.2f}")
print(f"  Median Final Balance: ${median_final:,.2f}")
print(f"  P(Final > ${initial_wealth:,.0f}): {prob_above_initial:.3f}")
print(f"  Min Final Balance: ${np.min(final_balances):,.2f}")
print(f"  Max Final Balance: ${np.max(final_balances):,.2f}")

plt.tight_layout()
plt.show()
```

### 4) Probability Balance > $30,000 at Age 75 (Original Game)

TODO: Report the probability estimate and interpret its practical meaning.

```{python}
#| label: q4-prob-original-py
#| echo: false

import numpy as np

# Using the final_balances from the 100 simulations above
# Estimate P(final > 30000) as the proportion of simulations where final > 30000

initial_wealth = 30000

# Calculate probability: proportion of simulations with final balance > initial
prob_above_initial = np.mean(final_balances > initial_wealth)

# Calculate number of simulations above initial
count_above = np.sum(final_balances > initial_wealth)
total_simulations = len(final_balances)

# Display results
print(f"Probability Estimate: P(Final > ${initial_wealth:,.0f})")
print(f"  Estimated Probability: {prob_above_initial:.3f}")
print(f"\nBreakdown:")
print(f"  Simulations with Final > ${initial_wealth:,.0f}: {count_above} out of {total_simulations}")
print(f"  Simulations with Final â‰¤ ${initial_wealth:,.0f}: {total_simulations - count_above} out of {total_simulations}")
print(f"\nInterpretation: Approximately {prob_above_initial*100:.1f}% of the time, ")
print(f"the final balance will exceed the initial ${initial_wealth:,.0f} investment.")
```

### 5) Modified Strategy (Bet Exactly 50% Each Round)

Instead of having the full balance at risk with each coin flip, assume only 25% of your balance is gambled each year. Compare this to the original game. Which is riskier? Which has better upside?

```{python}
#| label: q5-modified-50pct-py
#| echo: false
#| fig-cap: "Modified strategy distribution (bet 25% each round)"

import numpy as np
import matplotlib.pyplot as plt

# Set seed for reproducibility
np.random.seed(42)

# Parameters
initial_wealth = 30000
prob_heads = 0.5
num_years = 40
num_simulations = 100

# Modified strategy: Only bet 25% of balance each year
# If heads: gain 50% on the 25% bet â†’ wealth = W + 0.25*W*0.5 = W*(1 + 0.125) = W*1.125
# If tails: lose 40% on the 25% bet â†’ wealth = W - 0.25*W*0.4 = W*(1 - 0.1) = W*0.9
multiplier_heads_modified = 1.125  # 1 + 0.25 * 0.5
multiplier_tails_modified = 0.9    # 1 - 0.25 * 0.4

# Function to simulate modified game
def simulate_modified_game(initial, prob_heads, mult_heads, mult_tails, years):
    """Simulate one modified game and return final balance"""
    wealth = initial
    for _ in range(years):
        coin_flip = np.random.binomial(1, prob_heads)
        if coin_flip == 1:  # Heads
            wealth = wealth * mult_heads
        else:  # Tails
            wealth = wealth * mult_tails
    return wealth

# Run 100 simulations for modified strategy
final_balances_modified = []
for sim in range(num_simulations):
    final_balance = simulate_modified_game(initial_wealth, prob_heads, 
                                          multiplier_heads_modified, 
                                          multiplier_tails_modified, num_years)
    final_balances_modified.append(final_balance)

final_balances_modified = np.array(final_balances_modified)

# Calculate statistics for modified strategy
mean_modified = np.mean(final_balances_modified)
median_modified = np.median(final_balances_modified)
prob_above_initial_modified = np.mean(final_balances_modified > initial_wealth)

# Recalculate original strategy stats if needed (using same seed)
np.random.seed(42)
def simulate_original_game(initial, prob_heads, mult_heads, mult_tails, years):
    """Simulate one original game and return final balance"""
    wealth = initial
    for _ in range(years):
        coin_flip = np.random.binomial(1, prob_heads)
        if coin_flip == 1:  # Heads
            wealth = wealth * mult_heads
        else:  # Tails
            wealth = wealth * mult_tails
    return wealth

final_balances_original = []
multiplier_heads_original = 1.5
multiplier_tails_original = 0.6
for sim in range(num_simulations):
    final_balance = simulate_original_game(initial_wealth, prob_heads, 
                                          multiplier_heads_original, 
                                          multiplier_tails_original, num_years)
    final_balances_original.append(final_balance)

final_balances_original = np.array(final_balances_original)
mean_original = np.mean(final_balances_original)
median_original = np.median(final_balances_original)
prob_above_initial_original = np.mean(final_balances_original > initial_wealth)

# Create comparison plots
fig, axes = plt.subplots(2, 1, figsize=(14, 12))

# Top plot: Side-by-side histograms
ax1 = axes[0]

# Plot both distributions
ax1.hist(final_balances_original, bins=30, alpha=0.6, label='Original Strategy', 
         color='steelblue', edgecolor='black')
ax1.hist(final_balances_modified, bins=30, alpha=0.6, label='Modified Strategy (25% bet)', 
         color='coral', edgecolor='black')

# Add vertical lines
ax1.axvline(x=initial_wealth, color='red', linestyle='--', linewidth=2,
           label=f'Initial: ${initial_wealth:,.0f}')
ax1.axvline(x=mean_original, color='darkblue', linestyle=':', linewidth=1.5,
           label=f'Original Mean: ${mean_original:,.0f}')
ax1.axvline(x=mean_modified, color='darkred', linestyle=':', linewidth=1.5,
           label=f'Modified Mean: ${mean_modified:,.0f}')

ax1.set_xlabel('Final Account Balance ($)', fontsize=12)
ax1.set_ylabel('Frequency', fontsize=12)
ax1.set_title('Comparison: Original vs Modified Strategy', fontsize=14, fontweight='bold')
ax1.grid(True, alpha=0.3, axis='y')
ax1.legend(fontsize=10)
ax1.xaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: f'${x:,.0f}'))

# Bottom plot: Overlapping histograms with better binning (log scale)
ax2 = axes[1]

# Create log-spaced bins
all_balances = np.concatenate([final_balances_original, final_balances_modified])
min_balance = np.min(all_balances)
max_balance = np.max(all_balances)
log_min = np.log10(max(min_balance, 1))
log_max = np.log10(max_balance)
log_bins = np.logspace(log_min, log_max, num=50)

ax2.hist(final_balances_original, bins=log_bins, alpha=0.6, label='Original Strategy', 
         color='steelblue', edgecolor='black')
ax2.hist(final_balances_modified, bins=log_bins, alpha=0.6, label='Modified Strategy (25% bet)', 
         color='coral', edgecolor='black')

ax2.axvline(x=initial_wealth, color='red', linestyle='--', linewidth=2,
           label=f'Initial: ${initial_wealth:,.0f}')

ax2.set_xscale('log')
ax2.set_xlabel('Final Account Balance ($, log scale)', fontsize=12)
ax2.set_ylabel('Frequency', fontsize=12)
ax2.set_title('Comparison: Log-Scale View', fontsize=14, fontweight='bold')
ax2.grid(True, alpha=0.3, axis='both', which='both')
ax2.legend(fontsize=10)
ax2.xaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: f'${x:,.0f}'))

plt.tight_layout()
plt.show()

# Print comparison statistics
print("="*60)
print("STRATEGY COMPARISON")
print("="*60)
print(f"\nOriginal Strategy (Full Balance at Risk):")
print(f"  Mean Final Balance: ${mean_original:,.2f}")
print(f"  Median Final Balance: ${median_original:,.2f}")
print(f"  P(Final > ${initial_wealth:,.0f}): {prob_above_initial_original:.3f}")
print(f"  Min: ${np.min(final_balances_original):,.2f}, Max: ${np.max(final_balances_original):,.2f}")

print(f"\nModified Strategy (25% of Balance at Risk):")
print(f"  Mean Final Balance: ${mean_modified:,.2f}")
print(f"  Median Final Balance: ${median_modified:,.2f}")
print(f"  P(Final > ${initial_wealth:,.0f}): {prob_above_initial_modified:.3f}")
print(f"  Min: ${np.min(final_balances_modified):,.2f}, Max: ${np.max(final_balances_modified):,.2f}")

print(f"\nComparison:")
print(f"  Mean Difference: ${mean_modified - mean_original:,.2f} ({((mean_modified/mean_original)-1)*100:+.1f}%)")
print(f"  Median Difference: ${median_modified - median_original:,.2f} ({((median_modified/median_original)-1)*100:+.1f}%)")
print(f"  Probability Difference: {prob_above_initial_modified - prob_above_initial_original:+.3f}")
print(f"  Max Balance - Original: ${np.max(final_balances_original):,.2f}")
print(f"  Max Balance - Modified: ${np.max(final_balances_modified):,.2f}")
```

### 6) Briefly Explain Your Findings From The Previous Step in Light of A Concept Known as the "Kelly Criterion"
 
What is the Kelly Criterion and how does it relate to the modified strategy?

The **Kelly Criterion** is a formula developed by John Kelly in 1956 that determines the optimal fraction of capital to bet in repeated investment opportunities to maximize long-term growth. The formula balances growth potential against risk of ruin.

For this investment game:
- **Original Strategy**: Bets 100% of wealth each time (multipliers: 1.5 or 0.6)
- **Modified Strategy**: Bets 25% of wealth each time (resulting multipliers: 1.125 or 0.9)

```{python}
#| label: kelly-calculation
#| echo: false

import numpy as np

# Game parameters
p = 0.5  # Probability of winning (heads)
q = 1 - p  # Probability of losing (tails)
win_gain = 0.5  # Gain 50% on heads
loss_amount = 0.4  # Lose 40% on tails

# Kelly Criterion calculation
# For asymmetric bets with known payoffs, the Kelly fraction is:
# f* = (p Ã— b - q) / b, where b is the net gain fraction

# Using the win gain as the odds
kelly_fraction = (p * win_gain - q * loss_amount) / win_gain

# Alternative calculation using expected log growth
# Kelly maximizes expected log wealth: E[log(W)] = p*log(1+win) + q*log(1-loss)
# Optimal f* satisfies: p/(1+win*f) - q/(1-loss*f) = 0
# For our case with f=0.25 (25% bet):
f_modified = 0.25

# Calculate expected log growth for different bet fractions
bet_fractions = np.linspace(0.01, 0.99, 100)
expected_log_growth = []

for f in bet_fractions:
    if f * loss_amount < 1:  # Avoid bankruptcy (loss < 100%)
        log_growth = p * np.log(1 + win_gain * f) + q * np.log(1 - loss_amount * f)
        expected_log_growth.append(log_growth)
    else:
        expected_log_growth.append(-np.inf)

expected_log_growth = np.array(expected_log_growth)

# Find optimal Kelly fraction (maximum expected log growth)
optimal_kelly_idx = np.argmax(expected_log_growth)
optimal_kelly_fraction = bet_fractions[optimal_kelly_idx]
max_log_growth = expected_log_growth[optimal_kelly_idx]

# Calculate for our strategies
log_growth_original = p * np.log(1.5) + q * np.log(0.6)  # f=1.0 (100% bet)
log_growth_modified = p * np.log(1.125) + q * np.log(0.9)  # f=0.25 (25% bet)

print("Kelly Criterion Analysis:")
print("="*50)
print(f"\nOptimal Kelly Fraction: {optimal_kelly_fraction:.3f} ({optimal_kelly_fraction*100:.1f}%)")
print(f"Maximum Expected Log Growth: {max_log_growth:.6f}")
print(f"\nOriginal Strategy (100% bet):")
print(f"  Expected Log Growth: {log_growth_original:.6f}")
print(f"  Fraction Bet: 1.00 (100%)")
print(f"\nModified Strategy (25% bet):")
print(f"  Expected Log Growth: {log_growth_modified:.6f}")
print(f"  Fraction Bet: 0.25 (25%)")
print(f"\nOptimal Kelly Strategy:")
print(f"  Expected Log Growth: {max_log_growth:.6f}")
print(f"  Fraction Bet: {optimal_kelly_fraction:.3f} ({optimal_kelly_fraction*100:.1f}%)")
print("\nInterpretation:")
if optimal_kelly_fraction < 0.25:
    print("  The modified strategy (25%) bets MORE than Kelly-optimal,")
    print("  suggesting it may still be too aggressive for long-term growth.")
elif optimal_kelly_fraction > 0.25:
    print("  The modified strategy (25%) bets LESS than Kelly-optimal,")
    print("  which is more conservative but safer (reduces risk of ruin).")
else:
    print("  The modified strategy aligns closely with the Kelly Criterion.")
```

**Key Insights:**

1. **Kelly Criterion Purpose**: The Kelly Criterion finds the bet fraction that maximizes the expected logarithm of wealth over many periods, preventing ruin while maximizing growth.

2. **Original Strategy (100% bet)**: This is "over-betting" relative to Kelly. While it offers higher expected returns, it carries higher risk of substantial losses and potential ruin over many periods.

3. **Modified Strategy (25% bet)**: This is more conservative than the original strategy. It reduces volatility and the risk of severe drawdowns, even if it may sacrifice some expected return. Whether 25% is optimal depends on the Kelly calculation above.

4. **Practical Implications**: 
   - **Risk Management**: The modified strategy's lower volatility makes it more suitable for investors with limited capital who cannot withstand large losses.
   - **Long-term Growth**: While the original strategy might show higher means in simulations, it also has a much wider distribution, with many outcomes well below the initial investment.
   - **Kelly Principle**: The Kelly Criterion suggests betting a fraction less than what might seem intuitively optimal, trading some upside for much better downside protection.

The modified strategy demonstrates the Kelly Criterion principle: **better risk-adjusted returns often come from betting less than you might initially think is optimal**, especially when facing asymmetric risks (large potential losses) like in this game.


## Professional Presentation (From Grading TLDR)

- **Clear narrative:** tell the story succinctly (aim for a 1â€“5 minute read)
- **Focus on insights:** risk profiles, counter-intuitive results, practical implications
- **Professional style:** concise writing, clean visuals, hide code where appropriate (`echo: false`)
- **Human interpretation:** explain what results mean for real decisions

## Submission Checklist âœ…

- [ ] Quarto document written with narrative and results
- [ ] Rendered to HTML successfully
- [ ] Repository `simulationChallenge` created on GitHub
- [ ] HTML committed and pushed
- [ ] GitHub Pages enabled (Deploy from a branch â†’ main â†’ /(root))
- [ ] Site accessible at `https://[your-username].github.io/simulationChallenge/`

## Tips

- Set random seeds for reproducibility
- Use object-oriented plotting with `matplotlib`
- Keep figures readable and labeled; prefer professional styling
- Commit early and often; render locally before pushing

